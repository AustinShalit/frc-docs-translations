# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, FIRST
# This file is distributed under the same license as the FIRST Robotics Competition package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Kaitlyn Kenwell <redrield@gmail.com>, 2020
# Sami G.-D., 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FIRST Robotics Competition 2020\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-06-26 00:48-0700\n"
"PO-Revision-Date: 2020-04-25 02:02+0000\n"
"Last-Translator: Sami G.-D., 2020\n"
"Language-Team: French (Canada) (https://www.transifex.com/wpilib/teams/109324/fr_CA/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fr_CA\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:2
msgid "Commands"
msgstr "Commandes"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:4
msgid ""
"Commands are simple state machines that perform high-level robot functions "
"using the methods defined by subsystems. Commands can be either idle, in "
"which they do nothing, or scheduled, in which the scheduler will execute a "
"specific set of the command’s code depending on the state of the command. "
"The ``CommandScheduler`` recognizes scheduled commands as being in one of "
"three states: initializing, executing, or ending. Commands specify what is "
"done in each of these states through the ``initialize()``, ``execute()`` and"
" ``end()`` methods.  Commands are represented in the command-based library "
"by the ``Command`` interface (`Java "
"<https://first.wpi.edu/FRC/roborio/release/docs/java/edu/wpi/first/wpilibj2/command/Command.html>`__,"
" `C++ "
"<https://first.wpi.edu/FRC/roborio/release/docs/cpp/classfrc2_1_1Command.html>`__)."
msgstr ""
"Les commandes sont des automates finis qui exécutent des fonctions de haut "
"niveau du robot en utilisant les méthodes définies dans les sous-systèmes. "
"Les commandes peuvent être soit à l'arrêt (elles ne font rien) ou "
"programmées; dans ce cas, le planificateur va exécuter un ensemble "
"spécifique du code de la commande en fonction de l'état actuel de la "
"commande. Le ``CommandScheduler`` reconnaît les commandes programmés comme "
"étant dans un de trois états: initialisation, exécution et terminaison. Les "
"commandes spécifient ce qui est exécuté dans chacun de ces états en "
"utilisant les méthodes ``initialize()``, ``execute()`` et ``end()``. Les "
"commandes sont représentées dans la bibliothèque orientée commande par "
"l'interface ``Command`` (`Java "
"<https://first.wpi.edu/FRC/roborio/release/docs/java/edu/wpi/first/wpilibj2/command/Command.html>`__,"
" `C++ "
"<https://first.wpi.edu/FRC/roborio/release/docs/cpp/classfrc2_1_1Command.html>`__)."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:7
msgid "Creating Commands"
msgstr "Créer des commandes"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:9
msgid ""
"In the C++ API, a `CRTP "
"<https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`__ is "
"used to allow certain Command methods to work with the object ownership "
"model.  Users should *always* extend the ``CommandHelper`` `class "
"<https://github.com/wpilibsuite/allwpilib/blob/master/wpilibNewCommands/src/main/native/include/frc2/command/CommandHelper.h>`__"
" when defining their own command classes, as is shown below."
msgstr ""
"Dans l'API C++, un `CRTP "
"<https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`__ est "
"utilisé pour permettre certaines méthodes Command de fonctionner avec le "
"modèle de propriété d'objets. L'utilisateur devrait *toujours* étendre la "
"`classe "
"<https://github.com/wpilibsuite/allwpilib/blob/master/wpilibNewCommands/src/main/native/include/frc2/command/CommandHelper.h>`__"
" ``CommandHelper`` lorsqu'il définir sa propre classes de commande, comme "
"démontré ci-dessous."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:11
msgid ""
"Similarly to subsystems, the recommended method for most users to create a "
"command is to subclass the abstract ``CommandBase`` class (`Java "
"<https://first.wpi.edu/FRC/roborio/release/docs/java/edu/wpi/first/wpilibj2/command/CommandBase.html>`__,"
" `C++ "
"<https://first.wpi.edu/FRC/roborio/release/docs/cpp/classfrc2_1_1CommandBase.html>`__),"
" as seen in the command-based template (`Java "
"<https://github.com/wpilibsuite/allwpilib/blob/master/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/templates/commandbased/commands/ExampleCommand.java>`__,"
" `C++ "
"<https://github.com/wpilibsuite/allwpilib/blob/master/wpilibcExamples/src/main/cpp/templates/commandbased/include/commands/ExampleCommand.h>`__):"
msgstr ""
"Comme pour les sous-systèmes, la méthode recommandée pour la plupart des "
"utilisateurs est de sous-classer la classe abstraite ``CommandBase`` (`Java "
"<https://first.wpi.edu/FRC/roborio/release/docs/java/edu/wpi/first/wpilibj2/command/CommandBase.html>`__,"
" `C++ "
"<https://first.wpi.edu/FRC/roborio/release/docs/cpp/classfrc2_1_1CommandBase.html>`__),"
" comme démontré dans le modèle de programmation orientée commande (`Java "
"<https://github.com/wpilibsuite/allwpilib/blob/master/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/templates/commandbased/commands/ExampleCommand.java>`__,"
" `C++ "
"<https://github.com/wpilibsuite/allwpilib/blob/master/wpilibcExamples/src/main/cpp/templates/commandbased/include/commands/ExampleCommand.h>`__):"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:31
msgid ""
"As before, this contains several convenience features. It automatically "
"overrides the ``getRequirements()`` method for users, returning a list of "
"requirements that is empty by default, but can be added to with the "
"``addRequirements()`` method. It also implements the ``Sendable`` interface,"
" and so can be sent to the dashboard - this provides a handy way for "
"scheduling commands for testing (via a button on the dashboard) without "
"needing to bind them to buttons on a controller."
msgstr ""
"Comme avant, cela permet l'accès à des fonctionnalités pratiques. Il "
"remplace automatiquement la méthode ``getRequirements()`` pour les "
"utilisateurs, qui retourne une liste des exigences qui est vide par défaut; "
"mais qui peut être ajoutée avec la méthode ``addRequirements()``. Il "
"implémente aussi l'interface ``Sendable`` et peut donc être envoyée au "
"Dashboard - cela permet de programmer facilement des commandes pour les "
"tests (par un bouton sur le tableau de bord) sans avoir besoin de les lier à"
" des boutons sur un contrôleur."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:34
msgid ""
"Also as before, advanced users seeking more flexibility are free to simply "
"create their own class implementing the ``Command`` interface."
msgstr ""
"Aussi comme avant, les utilisateurs avancées recherchant plus de flexibilité"
" peuvent simplement créer leur propre classe qui implémente l'interface "
"``Command``."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:37
msgid "The Structure of a Command"
msgstr "La structure d'une commande"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:39
msgid ""
"While subsystems are fairly freeform, and may generally look like whatever "
"the user wishes them to, commands are quite a bit more constrained. Command "
"code must specify what the command will do in each of its possible states. "
"This is done by overriding the ``initialize()``, ``execute()``, and "
"``end()`` methods. Additionally, a command must be able to tell the "
"scheduler when (if ever) it has finished execution - this is done by "
"overriding the ``isFinished()`` method. All of these methods are defaulted "
"to reduce clutter in user code: ``initialize()``, ``execute()``, and "
"``end()`` are defaulted to simply do nothing, while ``isFinished()`` is "
"defaulted to return false (resulting in a command that never ends)."
msgstr ""
"Tandis que les sous-systèmes, qui n'ont pas de structure définie et qui "
"peuvent généralement ressembler à ce que l'utilisateur souhaite, les "
"commandes sont beaucoup plus contraignantes. Le code des commandes doit "
"spécifier qu'est-ce que la commande va faire dans chacun des états "
"possibles. Cela se fait en remplacer les méthodes ``initialize()``, "
"``execute()`` et ``end()``. De plus, une commande doit être capable de dire "
"au planificateur quand elle a terminé son exécution (s'il y a lieu) - cela "
"se fait par le remplacement de la méthode ``isFinished()``. Toutes ces "
"méthodes sont vide par défaut pour réduire l'encombrement dans le code de "
"l'utilisateur. ``initialize()``, ``execute()`` et ``end()`` sont vide par "
"défaut, pour ne rien exécuter, et ``isFinished()`` retourne faux par défaut "
"(résultant en une commande qui ne termine jamais)."

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:42
msgid "Initialization"
msgstr "Initialisation"

#: ../../frc-docs/source/docs/software/commandbased/commands.rst:47
msgid "Execution"
msgstr "Exécution"
